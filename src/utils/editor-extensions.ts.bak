import { StateField, StateEffect } from '@codemirror/state';
import { Decoration, DecorationSet, EditorView, showTooltip, type TooltipView } from '@codemirror/view';
import type { HarperIssue, Suggestion } from '../types';
import { IssueSeverity } from '../types';
import { render } from 'solid-js/web';
import ContextMenu from '../components/ContextMenu';

// Effect to update issues
export const updateIssuesEffect = StateEffect.define<HarperIssue[]>();

// Effect to update selected issue
export const setSelectedIssueEffect = StateEffect.define<string | null>();

// Effect to show context menu
export const showContextMenuEffect = StateEffect.define<{ issueId: string; pos: number } | null>();

// Custom theme for underlines and highlights using CodeMirror's baseTheme
// Using Flexoki color scheme
const issueTheme = EditorView.baseTheme({
	'.cm-issue-error': {
		textDecoration: 'underline solid',
		textDecorationColor: '#D14D41', // flexoki-red
		textDecorationThickness: '2px',
		textUnderlineOffset: '2px',
		textDecorationSkipInk: 'auto',
	},
	'.cm-issue-warning': {
		textDecoration: 'underline solid',
		textDecorationColor: '#D0A215', // flexoki-yellow
		textDecorationThickness: '2px',
		textUnderlineOffset: '2px',
		textDecorationSkipInk: 'auto',
	},
	'.cm-issue-info': {
		textDecoration: 'underline solid',
		textDecorationColor: '#4385BE', // flexoki-blue
		textDecorationThickness: '2px',
		textUnderlineOffset: '2px',
		textDecorationSkipInk: 'auto',
	},
	'.cm-issue-selected': {
		backgroundColor: 'rgba(58, 169, 159, 0.3)', // flexoki-cyan with opacity
	},
	'.cm-tooltip.cm-tooltip-above, .cm-tooltip.cm-tooltip-below': {
		'&.cm-tooltip-cursor': {
			backgroundColor: 'transparent',
			border: 'none',
		},
	},
});

// StateField to track current issues and selected issue
export const issueField = StateField.define<{ issues: HarperIssue[]; selectedId: string | null }>({
	create() {
		return { issues: [], selectedId: null };
	},
	update(state, tr) {
		let newState = state;

		for (const effect of tr.effects) {
			if (effect.is(updateIssuesEffect)) {
				newState = { ...newState, issues: effect.value };
			}
			if (effect.is(setSelectedIssueEffect)) {
				newState = { ...newState, selectedId: effect.value };
			}
		}

		return newState;
	},
});

// StateField for decorations
export const issueDecorationsField = StateField.define<DecorationSet>({
	create() {
		return Decoration.none;
	},
	update(decorations, tr) {
		// Always map decorations through document changes first to keep positions in sync
		decorations = decorations.map(tr.changes);

		const hasNewIssues = tr.effects.some(e => e.is(updateIssuesEffect));
		const hasSelectionChange = tr.effects.some(e => e.is(setSelectedIssueEffect));
		const issueState = tr.state.field(issueField);

		if (hasNewIssues) {
			// Rebuild all decorations when issues change
			return buildDecorations(issueState.issues, issueState.selectedId);
		}
		
		if (hasSelectionChange) {
			// Update selection highlighting on existing (already mapped) decorations
			return updateDecorationsForSelection(decorations, issueState.selectedId);
		}

		return decorations;
	},
	provide: f => EditorView.decorations.from(f),
});

function buildDecorations(issues: HarperIssue[], selectedId: string | null): DecorationSet {
	const decorations: Array<{ from: number; to: number; decoration: Decoration }> = [];

	for (const issue of issues) {
		const span = issue.lint.span();
		const isSelected = issue.id === selectedId;
		const cssClass = getSeverityCssClass(issue.severity) + (isSelected ? ' cm-issue-selected' : '');

		// Use Decoration.mark for inline text decoration
		decorations.push({
			from: span.start,
			to: span.end,
			decoration: Decoration.mark({
				class: cssClass,
				attributes: { 'data-issue-id': issue.id },
			}),
		});
	}

	// Sort by position to ensure proper decoration order
	decorations.sort((a, b) => a.from - b.from);

	return Decoration.set(decorations.map(d => d.decoration.range(d.from, d.to)));
}

function updateDecorationsForSelection(decorations: DecorationSet, selectedId: string | null): DecorationSet {
	const updated: Array<{ from: number; to: number; decoration: Decoration }> = [];

	// Iterate through existing decorations and rebuild them with updated selection class
	decorations.between(0, Number.MAX_SAFE_INTEGER, (from, to, value) => {
		if (value.spec.attributes && value.spec.attributes['data-issue-id']) {
			const issueId = value.spec.attributes['data-issue-id'] as string;
			const isSelected = issueId === selectedId;
			
			// Extract the base class (severity) from the current decoration
			let baseClass = '';
			if (value.spec.class) {
				baseClass = value.spec.class.replace(' cm-issue-selected', '');
			}
			
			const cssClass = baseClass + (isSelected ? ' cm-issue-selected' : '');
			
			updated.push({
				from,
				to,
				decoration: Decoration.mark({
					class: cssClass,
					attributes: { 'data-issue-id': issueId },
				}),
			});
		}
	});

	return Decoration.set(updated.map(d => d.decoration.range(d.from, d.to)));
}

function getSeverityCssClass(severity: IssueSeverity): string {
	switch (severity) {
		case IssueSeverity.Error:
			return 'cm-issue-error';
		case IssueSeverity.Warning:
			return 'cm-issue-warning';
		case IssueSeverity.Info:
			return 'cm-issue-info';
	}
}

// Actions interface for applying suggestions
interface IssueActions {
	onApplySuggestion: (issueId: string, suggestion: Suggestion) => void;
	onAddToDictionary: (word: string) => void;
	onIgnore: (issueId: string) => void;
}

let issueActions: IssueActions | null = null;

export function setIssueActions(actions: IssueActions) {
	issueActions = actions;
}

// Helper to find issue at cursor position
function findIssueAtPos(state: any, pos: number): HarperIssue | null {
	const issueState = state.field(issueField);
	const decorations = state.field(issueDecorationsField);
	
	let foundIssueId: string | null = null;
	decorations.between(pos, pos, (from: number, to: number, value: any) => {
		if (value.spec.attributes && value.spec.attributes['data-issue-id']) {
			foundIssueId = value.spec.attributes['data-issue-id'] as string;
			return false;
		}
	});
	
	if (foundIssueId) {
		return issueState.issues.find((i: HarperIssue) => i.id === foundIssueId) || null;
	}
	
	return null;
}

// Custom autocomplete source for Harper issues
function harperAutocomplete(context: CompletionContext): CompletionResult | null {
	const issue = findIssueAtPos(context.state, context.pos);
	if (!issue || !issueActions) return null;
	
	const suggestions = issue.lint.suggestions();
	const span = issue.lint.span();
	const options: Completion[] = [];
	
	// Add suggestion completions
	for (const suggestion of suggestions) {
		const kind = suggestion.kind();
		const isRemove = kind === SuggestionKind.Remove;
		const replacementText = isRemove ? '' : suggestion.get_replacement_text();
		const label = isRemove ? '(Remove)' : replacementText;
		
		options.push({
			label,
			detail: isRemove ? 'Remove this text' : 'Replace',
			apply: () => {
				if (issueActions) {
					issueActions.onApplySuggestion(issue.id, suggestion);
				}
			},
			type: 'text',
		});
	}
	
	// Add dictionary option for spelling issues
	const isSpelling = issue.lint.lint_kind().toLowerCase().includes('spelling');
	if (isSpelling) {
		options.push({
			label: 'Add to Dictionary',
			detail: 'Add word to dictionary',
			apply: () => {
				if (issueActions) {
					issueActions.onAddToDictionary(issue.lint.get_problem_text());
				}
			},
			type: 'keyword',
		});
	}
	
	// Add ignore option
	options.push({
		label: 'Ignore',
		detail: 'Ignore this issue',
		apply: () => {
			if (issueActions) {
				issueActions.onIgnore(issue.id);
			}
		},
		type: 'keyword',
	});
	
	return {
		from: span.start,
		to: span.end,
		options,
		validFor: /^$/,  // Don't filter as user types
	};
}

// Hover tooltip for issue details
function issueHoverTooltip(view: EditorView, pos: number, _side: -1 | 1): Tooltip | null {
	const issue = findIssueAtPos(view.state, pos);
	if (!issue) return null;
	
	const span = issue.lint.span();
	const dom = document.createElement('div');
	dom.className = 'cm-issue-tooltip';
	
	const severityClass = getSeverityCssClass(issue.severity).replace('cm-issue-', '');
	
	dom.innerHTML = `
		<div class="cm-issue-tooltip-content">
			<div class="cm-issue-tooltip-header">
				<span class="cm-issue-tooltip-severity cm-issue-tooltip-severity-${severityClass}">${issue.severity}</span>
				<span class="cm-issue-tooltip-message">${issue.lint.message()}</span>
			</div>
			<div class="cm-issue-tooltip-rule">${issue.lint.lint_kind()}</div>
		</div>
	`;
	
	return {
		pos: span.start,
		end: span.end,
		create: () => ({ dom }),
		above: true,
	};
}

// Export the autocomplete extension
export const harperAutocompletion = autocompletion({
	override: [harperAutocomplete],
	activateOnTyping: false,  // Only activate on Ctrl+Space
	closeOnBlur: true,
});

// Export the hover tooltip extension
export const harperHoverTooltip = hoverTooltip(issueHoverTooltip, {
	hideOnChange: false,
	hoverTime: 300,
});

// Dark editor theme with Flexoki colors
const darkEditorTheme = EditorView.theme({
	'&': {
		color: '#CECDC3', // flexoki-tx
		backgroundColor: '#100F0F', // flexoki-bg
	},
	'.cm-content': {
		caretColor: '#CECDC3',
	},
	'&.cm-focused .cm-cursor': {
		borderLeftColor: '#CECDC3',
	},
	'&.cm-focused .cm-selectionBackground, ::selection': {
		backgroundColor: '#3aa99f4c !important', // flexoki-cyan with opacity (matching text-selection)
	},
	'.cm-selectionBackground': {
		backgroundColor: '#3aa99f4c !important',
	},
	'.cm-gutters': {
		backgroundColor: '#1C1B1A', // flexoki-bg-2
		color: '#878580', // flexoki-tx-2
		border: 'none',
	},
	'.cm-activeLineGutter': {
		backgroundColor: '#282726', // flexoki-ui
	},
	'.cm-activeLine': {
		backgroundColor: 'rgba(40, 39, 38, 0.5)', // flexoki-ui with transparency
	},
}, { dark: true });

export { issueTheme, darkEditorTheme };
